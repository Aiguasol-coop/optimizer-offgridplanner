import os
import json
import io

import jsonschema.exceptions
from fastapi import FastAPI, Request, Response, File, UploadFile, HTTPException
from fastapi.encoders import jsonable_encoder
from fastapi.responses import JSONResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from fastapi.responses import StreamingResponse
import fastapi
import importlib.util
from jsonschema import validate

try:
    from worker import app as celery_app
except ModuleNotFoundError:
    from .worker import app as celery_app
import celery.states as states

app = FastAPI()

SERVER_ROOT = os.path.dirname(__file__)

app.mount(
    "/static", StaticFiles(directory=os.path.join(SERVER_ROOT, "static")), name="static"
)

templates = Jinja2Templates(directory=os.path.join(SERVER_ROOT, "templates"))


# option for routing `@app.X` where `X` is one of
# post: to create data.
# get: to read data.
# put: to update data.
# delete: to delete data.

# while it might be tempting to use BackgroundTasks for oemof simulation, those might take up
# resources and it is better to start them in an independent process. BackgroundTasks are for
# not resource intensive processes(https://fastapi.tiangolo.com/tutorial/background-tasks/)


# `127.0.0.1:8000/docs` endpoint will have autogenerated docs for the written code

# Test Driven Development --> https://fastapi.tiangolo.com/tutorial/testing/

def validate_simulation_queue(queue):
    if queue not in ["grid", "supply"]:
        raise HTTPException(status_code=400, detail=f'{queue} is not an accepted argument. Simulation options are "grid" or "supply"')
    return

@app.get("/")
def index(request: Request) -> Response:

    return templates.TemplateResponse(
        "index.html",
        {
            "request": request,
        },
    )


@app.get("/health/liveness", status_code=fastapi.status.HTTP_200_OK)
async def liveness():
    """Liveness check endpoint."""
    # You can implement any additional checks here (e.g., checking if the app can access a database)
    return {"status": "alive"}


@app.post("/sendjson/{queue}")
async def simulate_json_variable(request: Request, queue: str = "supply"):
    """Receive mvs simulation parameter in json post request and send it to simulator"""
    validate_simulation_queue(queue)
    input_dict = await request.json()

    # send the task to celery
    task = celery_app.send_task(
        f"{queue}.run_simulation", args=[input_dict], queue=queue, kwargs={}
    )
    queue_answer = await check_task(task.id)

    return queue_answer


@app.post("/uploadjson/{queue}")
def simulate_uploaded_json_files(
    request: Request, queue: str, json_file: UploadFile = File(...),
):
    """Receive mvs simulation parameter in json post request and send it to simulator
    the value of `name` property of the input html tag should be `json_file` as the second
    argument of this function
    """
    json_content = jsonable_encoder(json_file.file.read())
    return run_simulation(request, input_json=json_content, queue=f"{queue}")


def run_simulation(request: Request, input_json=None, queue="supply") -> Response:
    """Send a simulation task to a celery worker"""

    if input_json is None:
        input_dict = {
            "name": "dummy_json_input",
            "secondary_dict": {"val1": 2, "val2": [5, 6, 7, 8]},
        }
    else:
        input_dict = json.loads(input_json)

    # validate input against JSONSchema
    schema = json.loads(get_schema(queue, "input").body)
    try:
        validate(input_dict, schema)
    except jsonschema.exceptions.ValidationError:
        raise HTTPException(status_code=400, detail=f'Input did not validate against JSONSchema. Hint: You can check the expected JSON format using the "/schema/grid/input" and "/schema/supply/input" endpoints.')

    # send the task to celery
    task = celery_app.send_task(
        f"{queue}.run_simulation", args=[input_dict], queue=queue, kwargs={}
    )

    return templates.TemplateResponse(
        "submitted_task.html", {"request": request, "task_id": task.id}
    )



@app.get("/check/{task_id}")
async def check_task(task_id: str) -> JSONResponse:
    res = celery_app.AsyncResult(task_id)
    task = {
        "server_info": None,
        "id": task_id,
        "status": res.state,
        "results": None,
    }
    if res.state == states.PENDING:
        task["status"] = res.state
    else:
        task["status"] = "DONE"
        results_as_dict = json.loads(res.result)
        server_info = results_as_dict.pop("SERVER")
        task["server_info"] = server_info
        task["results"] = results_as_dict
        if "ERROR" in task["results"]:
            task["status"] = "ERROR"
            task["results"] = results_as_dict

    return JSONResponse(content=jsonable_encoder(task))


@app.get("/abort/{task_id}")
async def revoke_task(task_id: str) -> JSONResponse:
    res = celery_app.AsyncResult(task_id)
    res.revoke(terminate=True)
    return JSONResponse(content=jsonable_encoder({"task_id": task_id, "aborted": True}))


@app.get("/schema/{queue}/{variant}")
def get_schema(queue: str, variant: str):
    schema_file = f"{queue}_schema"
    schema_path = os.path.join(os.path.dirname(__file__), "static", f"{schema_file}.py")

    if not os.path.isfile(schema_path):
        raise HTTPException(status_code=404, detail=f"Schema file '{schema_file}' not found")

    try:
        spec = importlib.util.spec_from_file_location(schema_file, schema_path)
        schema_module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(schema_module)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error while loading the module: {e}")

    schema_var = f"{schema_file}_{variant}"

    if not hasattr(schema_module, schema_var):
        raise HTTPException(status_code=404, detail=f"Schema variable '{schema_var}' not found in {schema_file}")

    return JSONResponse(content=getattr(schema_module, schema_var))

